<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>core_lib/src/miniz.h Source File | Pencil2D Developer Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
 <header class="site-header" role="banner">
  <div class="wrapper">
   <img src="pencil2d.png" style="float:left; width:54px; margin-right: 10px;" />
   <a class="site-title" href="//www.pencil2d.org/">Pencil2D Animation</a>
   <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
     <span class="menu-icon">
      <svg viewBox="0 0 18 15" width="18px" height="15px">
       <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
       <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
       <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
      </svg>
     </span>
    </label>
    <div class="trigger">
     <a class="page-link" href="//www.pencil2d.org/download">Download</a>
     <a class="page-link" href="//www.pencil2d.org/community">Community</a>
     <a class="page-link" href="//www.pencil2d.org/news.html">News</a>
     <a class="page-link" href="//www.pencil2d.org/doc">Docs</a>
     <a class="page-link" href="//www.pencil2d.org/contribute">Contribute</a>
    </div>
   </nav>
  </div>
 </header>
</div>
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Articles</span></a></li>
      <li class="current"><a href="annotated.html"><span>Code</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6b71f9c233d9519f4af35a38b852209b.html">core_lib</a></li><li class="navelem"><a class="el" href="dir_f830c7608682f699c450179736650af1.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">miniz.h</div></div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/* miniz.c 2.1.0 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment">   See &quot;unlicense&quot; statement at the end of this file.</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment">   Rich Geldreich &lt;richgel99@gmail.com&gt;, last updated Oct. 13, 2013</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment">   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"></span> </div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment">   Most API&#39;s defined in miniz.c are optional. For example, to disable the archive related functions just define</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment">   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment"></span> </div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment">   * Low-level Deflate/Inflate implementation notes:</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"></span> </div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment">     Compression: Use the &quot;tdefl&quot; API&#39;s. The compressor supports raw, static, and dynamic blocks, lazy or</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment">     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment">     approximately as well as zlib.</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment"></span> </div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="comment">     Decompression: Use the &quot;tinfl&quot; API&#39;s. The entire decompressor is implemented as a single function</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="comment">     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment">     block large enough to hold the entire file.</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment"></span> </div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="comment">     The low-level tdefl/tinfl API&#39;s do not make any use of dynamic memory allocation.</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="comment"></span> </div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="comment">   * zlib-style API notes:</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="comment"></span> </div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="comment">     miniz.c implements a fairly large subset of zlib. There&#39;s enough functionality present for it to be a drop-in</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="comment">     zlib replacement in many apps:</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="comment">        The z_stream struct, optional memory allocation callbacks</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="comment">        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="comment">        inflateInit/inflateInit2/inflate/inflateReset/inflateEnd</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="comment">        compress, compress2, compressBound, uncompress</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="comment">        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="comment">        Supports raw deflate streams or standard zlib streams with adler-32 checking.</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="comment"></span> </div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="comment">     Limitations:</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="comment">      The callback API&#39;s are not implemented yet. No support for gzip headers or zlib static dictionaries.</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="comment">      I&#39;ve tried to closely emulate zlib&#39;s various flavors of stream flushing and return status codes, but</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="comment">      there are no guarantees that miniz.c pulls this off perfectly.</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="comment"></span> </div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="comment">   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by</span></div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span><span class="comment">     Alex Evans. Supports 1-4 bytes/pixel images.</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="comment"></span> </div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span><span class="comment">   * ZIP archive API notes:</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="comment"></span> </div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span><span class="comment">     The ZIP archive API&#39;s where designed with simplicity and efficiency in mind, with just enough abstraction to</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="comment">     get the job done with minimal fuss. There are simple API&#39;s to retrieve file information, read files from</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="comment">     existing archives, create new archives, append new files to existing archives, or clone archive data from</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span><span class="comment">     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span><span class="comment">     or you can specify custom file read/write callbacks.</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="comment"></span> </div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span><span class="comment">     - Archive reading: Just call this function to read a single file from a disk archive:</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="comment"></span> </div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="comment">      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span><span class="comment">        size_t *pSize, mz_uint zip_flags);</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment"></span> </div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment">     For more complex cases, use the &quot;mz_zip_reader&quot; functions. Upon opening an archive, the entire central</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span><span class="comment">     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment"></span> </div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment">     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="comment"></span> </div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment">     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="comment"></span> </div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment">     The locate operation can optionally check file comments too, which (as one example) can be used to identify</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment">     multiple versions of the same file in an archive. This function uses a simple linear search through the central</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="comment">     directory, so it&#39;s not very fast.</span></div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment"></span> </div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span><span class="comment">     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="comment">     retrieve detailed info on each file by calling mz_zip_reader_file_stat().</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span><span class="comment"></span> </div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span><span class="comment">     - Archive creation: Use the &quot;mz_zip_writer&quot; functions. The ZIP writer immediately writes compressed file data</span></div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="comment">     to disk and builds an exact image of the central directory in memory. The central directory image is written</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span><span class="comment">     all at once at the end of the archive file when the archive is finalized.</span></div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span><span class="comment"></span> </div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span><span class="comment">     The archive writer can optionally align each file&#39;s local header and file data to any power of 2 alignment,</span></div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span><span class="comment">     which can be useful when the archive will be read from optical media. Also, the writer supports placing</span></div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span><span class="comment">     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span><span class="comment">     readable by any ZIP tool.</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span><span class="comment"></span> </div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="comment">     - Archive appending: The simple way to add a single file to an archive is to call this function:</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span><span class="comment"></span> </div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span><span class="comment">      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="comment">        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="comment"></span> </div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="comment">     The archive will be created if it doesn&#39;t already exist, otherwise it&#39;ll be appended to.</span></div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="comment">     Note the appending is done in-place and is not an atomic operation, so if something goes wrong</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="comment">     during the operation it&#39;s possible the archive could be left without a central directory (although the local</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span><span class="comment">     file headers and file data will be fine, so the archive will be recoverable).</span></div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="comment"></span> </div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="comment">     For more complex archive modification scenarios:</span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span><span class="comment">     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="comment">     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span><span class="comment">     compressed file data as-is). When you&#39;re done, delete the old archive and rename the newly written archive, and</span></div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span><span class="comment">     you&#39;re done. This is safe but requires a bunch of temporary disk space or heap memory.</span></div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment"></span> </div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment">     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),</span></div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment">     append new files as needed, then finalize the archive which will write an updated central directory to the</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment">     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There&#39;s a</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment">     possibility that the archive&#39;s central directory could be lost with this method if anything goes wrong, though.</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment"></span> </div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment">     - ZIP archive support limitations:</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment">     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment">     Requires streams capable of seeking.</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="comment"></span> </div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span><span class="comment">   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span><span class="comment">     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.</span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span><span class="comment"></span> </div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span><span class="comment">   * Important: For best perf. be sure to customize the below macros for your target platform:</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment">     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment">     #define MINIZ_LITTLE_ENDIAN 1</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment">     #define MINIZ_HAS_64BIT_REGISTERS 1</span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment"></span> </div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment">   * On platforms using glibc, Be sure to &quot;#define _LARGEFILE64_SOURCE 1&quot; before including miniz.c to ensure miniz</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment">     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won&#39;t be able to process large files</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment">     (i.e. 32-bit stat() fails for me on files &gt; 0x7FFFFFFF bytes).</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment">*/</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span> </div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span> </div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span> </div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span> </div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span> </div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment">/* Defines to completely disable specific portions of miniz.c: </span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment">   If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl. */</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span> </div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment">/* Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O. */</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment">/*#define MINIZ_NO_STDIO */</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span> </div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment">/* If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or */</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment">/* get/set file times, and the C run-time funcs that get/set times won&#39;t be called. */</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment">/* The current downside is the times written to your archives will be from 1979. */</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="preprocessor">#define MINIZ_NO_TIME</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span> </div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span><span class="comment">/* Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API&#39;s. */</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="comment">/*#define MINIZ_NO_ARCHIVE_APIS */</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span> </div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment">/* Define MINIZ_NO_ARCHIVE_WRITING_APIS to disable all writing related ZIP archive API&#39;s. */</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment">/*#define MINIZ_NO_ARCHIVE_WRITING_APIS */</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span> </div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment">/* Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API&#39;s. */</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment">/*#define MINIZ_NO_ZLIB_APIS */</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span> </div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment">/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib. */</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment">/*#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES */</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span> </div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment">/* Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc. </span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span><span class="comment">   Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span><span class="comment">   callbacks to the zlib and archive API&#39;s, and a few stand-alone helper API&#39;s which don&#39;t provide custom user</span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span><span class="comment">   functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won&#39;t work. */</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span><span class="comment">/*#define MINIZ_NO_MALLOC */</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span> </div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="preprocessor">#if defined(__TINYC__) &amp;&amp; (defined(__linux) || defined(__linux__))</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment">/* TODO: Work around &quot;error: include file &#39;sys\utime.h&#39; when compiling with tcc on Linux */</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span><span class="preprocessor">#define MINIZ_NO_TIME</span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span> </div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="preprocessor">#include &lt;stddef.h&gt;</span></div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span> </div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span><span class="preprocessor">#if !defined(MINIZ_NO_TIME) &amp;&amp; !defined(MINIZ_NO_ARCHIVE_APIS)</span></div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span> </div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span><span class="preprocessor">#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)</span></div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span><span class="comment">/* MINIZ_X86_OR_X64_CPU is only used to help set the below macros. */</span></div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span><span class="preprocessor">#define MINIZ_X86_OR_X64_CPU 1</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="preprocessor">#define MINIZ_X86_OR_X64_CPU 0</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span> </div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="preprocessor">#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment">/* Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian. */</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="preprocessor">#define MINIZ_LITTLE_ENDIAN 1</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span><span class="preprocessor">#define MINIZ_LITTLE_ENDIAN 0</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span> </div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span><span class="comment">/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES only if not set */</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span><span class="preprocessor">#if !defined(MINIZ_USE_UNALIGNED_LOADS_AND_STORES)</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="preprocessor">#if MINIZ_X86_OR_X64_CPU</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment">/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU&#39;s that permit efficient integer loads and stores from unaligned addresses. */</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="preprocessor">#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="preprocessor">#define MINIZ_UNALIGNED_USE_MEMCPY</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="preprocessor">#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span> </div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span><span class="preprocessor">#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)</span></div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span><span class="comment">/* Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don&#39;t involve compiler generated calls to helper functions). */</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span><span class="preprocessor">#define MINIZ_HAS_64BIT_REGISTERS 1</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span><span class="preprocessor">#define MINIZ_HAS_64BIT_REGISTERS 0</span></div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span> </div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span> </div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span><span class="comment">/* ------------------- zlib-style API Definitions. */</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span> </div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span><span class="comment">/* For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits! */</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mz_ulong;</div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span> </div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span><span class="comment">/* mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you&#39;ve modified the MZ_MALLOC macro) to release a block allocated from the heap. */</span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span><span class="keywordtype">void</span> mz_free(<span class="keywordtype">void</span> *p);</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span> </div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span><span class="preprocessor">#define MZ_ADLER32_INIT (1)</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="comment">/* mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. */</span></div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span>mz_ulong mz_adler32(mz_ulong adler, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> buf_len);</div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span> </div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span><span class="preprocessor">#define MZ_CRC32_INIT (0)</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span><span class="comment">/* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>mz_ulong mz_crc32(mz_ulong crc, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> buf_len);</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span> </div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span><span class="comment">/* Compression strategies. */</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span>{</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span>    MZ_DEFAULT_STRATEGY = 0,</div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>    MZ_FILTERED = 1,</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>    MZ_HUFFMAN_ONLY = 2,</div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span>    MZ_RLE = 3,</div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>    MZ_FIXED = 4</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>};</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span> </div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span><span class="comment">/* Method */</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span><span class="preprocessor">#define MZ_DEFLATED 8</span></div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span> </div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span><span class="comment">/* Heap allocation callbacks.</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span><span class="comment">Note that mz_alloc_func parameter types purpsosely differ from zlib&#39;s: items/size is size_t, not unsigned long. */</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *(*mz_alloc_func)(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">size_t</span> items, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="keyword">typedef</span> void (*mz_free_func)(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">void</span> *address);</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *(*mz_realloc_func)(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">void</span> *address, <span class="keywordtype">size_t</span> items, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span> </div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment">/* Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. */</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span>{</div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>    MZ_NO_COMPRESSION = 0,</div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>    MZ_BEST_SPEED = 1,</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>    MZ_BEST_COMPRESSION = 9,</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span>    MZ_UBER_COMPRESSION = 10,</div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>    MZ_DEFAULT_LEVEL = 6,</div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>    MZ_DEFAULT_COMPRESSION = -1</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>};</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span> </div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span><span class="preprocessor">#define MZ_VERSION &quot;10.1.0&quot;</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span><span class="preprocessor">#define MZ_VERNUM 0xA100</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span><span class="preprocessor">#define MZ_VER_MAJOR 10</span></div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span><span class="preprocessor">#define MZ_VER_MINOR 1</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span><span class="preprocessor">#define MZ_VER_REVISION 0</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="preprocessor">#define MZ_VER_SUBREVISION 0</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span> </div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span><span class="preprocessor">#ifndef MINIZ_NO_ZLIB_APIS</span></div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span> </div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span><span class="comment">/* Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). */</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>{</div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>    MZ_NO_FLUSH = 0,</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>    MZ_PARTIAL_FLUSH = 1,</div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>    MZ_SYNC_FLUSH = 2,</div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>    MZ_FULL_FLUSH = 3,</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>    MZ_FINISH = 4,</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>    MZ_BLOCK = 5</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>};</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span> </div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span><span class="comment">/* Return status codes. MZ_PARAM_ERROR is non-standard. */</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span>{</div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span>    MZ_OK = 0,</div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span>    MZ_STREAM_END = 1,</div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span>    MZ_NEED_DICT = 2,</div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span>    MZ_ERRNO = -1,</div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>    MZ_STREAM_ERROR = -2,</div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>    MZ_DATA_ERROR = -3,</div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span>    MZ_MEM_ERROR = -4,</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>    MZ_BUF_ERROR = -5,</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>    MZ_VERSION_ERROR = -6,</div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>    MZ_PARAM_ERROR = -10000</div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span>};</div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span> </div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="comment">/* Window bits */</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="preprocessor">#define MZ_DEFAULT_WINDOW_BITS 15</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span> </div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="keyword">struct </span>mz_internal_state;</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span> </div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment">/* Compression/decompression stream struct. */</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno"><a class="line" href="structmz__stream__s.html">  282</a></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structmz__stream__s.html">mz_stream_s</a></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span>{</div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span>    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *next_in; <span class="comment">/* pointer to next byte to read */</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> avail_in;        <span class="comment">/* number of bytes available at next_in */</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span>    mz_ulong total_in;            <span class="comment">/* total number of bytes consumed so far */</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span> </div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *next_out; <span class="comment">/* pointer to next byte to write */</span></div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> avail_out;  <span class="comment">/* number of bytes that can be written to next_out */</span></div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>    mz_ulong total_out;      <span class="comment">/* total number of bytes produced so far */</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span> </div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span>    <span class="keywordtype">char</span> *msg;                       <span class="comment">/* error msg (unused) */</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span>    <span class="keyword">struct </span>mz_internal_state *state; <span class="comment">/* internal state, allocated by zalloc/zfree */</span></div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span> </div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span>    mz_alloc_func zalloc; <span class="comment">/* optional heap allocation function (defaults to malloc) */</span></div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span>    mz_free_func zfree;   <span class="comment">/* optional heap free function (defaults to free) */</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span>    <span class="keywordtype">void</span> *opaque;         <span class="comment">/* heap alloc function user pointer */</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span> </div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span>    <span class="keywordtype">int</span> data_type;     <span class="comment">/* data_type (unused) */</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span>    mz_ulong adler;    <span class="comment">/* adler32 of the source or uncompressed data */</span></div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span>    mz_ulong reserved; <span class="comment">/* not used */</span></div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span>} <a class="code hl_struct" href="structmz__stream__s.html">mz_stream</a>;</div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span> </div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="keyword">typedef</span> <a class="code hl_struct" href="structmz__stream__s.html">mz_stream</a> *<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a>;</div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span> </div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span><span class="comment">/* Returns the version string of miniz.c. */</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span><span class="keyword">const</span> <span class="keywordtype">char</span> *mz_version(<span class="keywordtype">void</span>);</div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span> </div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span><span class="comment">/* mz_deflateInit() initializes a compressor with default options: */</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span><span class="comment">/* Parameters: */</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span><span class="comment">/*  pStream must point to an initialized mz_stream struct. */</span></div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span><span class="comment">/*  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. */</span></div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span><span class="comment">/*  level 1 enables a specially optimized compression function that&#39;s been optimized purely for performance, not ratio. */</span></div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment">/*  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) */</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment">/* Return values: */</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment">/*  MZ_OK on success. */</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment">/*  MZ_STREAM_ERROR if the stream is bogus. */</span></div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span><span class="comment">/*  MZ_PARAM_ERROR if the input parameters are bogus. */</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment">/*  MZ_MEM_ERROR on out of memory. */</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="keywordtype">int</span> mz_deflateInit(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream, <span class="keywordtype">int</span> level);</div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span> </div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span><span class="comment">/* mz_deflateInit2() is like mz_deflate(), except with more control: */</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span><span class="comment">/* Additional parameters: */</span></div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span><span class="comment">/*   method must be MZ_DEFLATED */</span></div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span><span class="comment">/*   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) */</span></div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span><span class="comment">/*   mem_level must be between [1, 9] (it&#39;s checked but ignored by miniz.c) */</span></div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span><span class="keywordtype">int</span> mz_deflateInit2(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> method, <span class="keywordtype">int</span> window_bits, <span class="keywordtype">int</span> mem_level, <span class="keywordtype">int</span> strategy);</div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span> </div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment">/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */</span></div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span><span class="keywordtype">int</span> mz_deflateReset(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream);</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span> </div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span><span class="comment">/* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span><span class="comment">/* Parameters: */</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span><span class="comment">/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */</span></div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span><span class="comment">/*   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. */</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span><span class="comment">/* Return values: */</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span><span class="comment">/*   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there&#39;s more output to be written but the output buffer is full). */</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span><span class="comment">/*   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don&#39;t call mz_deflate() on the stream anymore. */</span></div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span><span class="comment">/*   MZ_STREAM_ERROR if the stream is bogus. */</span></div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span><span class="comment">/*   MZ_PARAM_ERROR if one of the parameters is invalid. */</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span><span class="comment">/*   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) */</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span><span class="keywordtype">int</span> mz_deflate(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream, <span class="keywordtype">int</span> flush);</div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span> </div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span><span class="comment">/* mz_deflateEnd() deinitializes a compressor: */</span></div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span><span class="comment">/* Return values: */</span></div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span><span class="comment">/*  MZ_OK on success. */</span></div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span><span class="comment">/*  MZ_STREAM_ERROR if the stream is bogus. */</span></div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="keywordtype">int</span> mz_deflateEnd(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream);</div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span> </div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="comment">/* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */</span></div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span>mz_ulong mz_deflateBound(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream, mz_ulong source_len);</div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span> </div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment">/* Single-call compression functions mz_compress() and mz_compress2(): */</span></div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment">/* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span><span class="keywordtype">int</span> mz_compress(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pDest, mz_ulong *pDest_len, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pSource, mz_ulong source_len);</div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span><span class="keywordtype">int</span> mz_compress2(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pDest, mz_ulong *pDest_len, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pSource, mz_ulong source_len, <span class="keywordtype">int</span> level);</div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span> </div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span><span class="comment">/* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */</span></div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span>mz_ulong mz_compressBound(mz_ulong source_len);</div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span> </div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span><span class="comment">/* Initializes a decompressor. */</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="keywordtype">int</span> mz_inflateInit(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream);</div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span> </div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment">/* mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: */</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment">/* window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). */</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="keywordtype">int</span> mz_inflateInit2(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream, <span class="keywordtype">int</span> window_bits);</div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span> </div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment">/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). */</span></div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="keywordtype">int</span> mz_inflateReset(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream);</div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span> </div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment">/* Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. */</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment">/* Parameters: */</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span><span class="comment">/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */</span></div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span><span class="comment">/*   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. */</span></div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span><span class="comment">/*   On the first call, if flush is MZ_FINISH it&#39;s assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). */</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="comment">/*   MZ_FINISH implies that there are no more source bytes available beside what&#39;s already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. */</span></div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span><span class="comment">/* Return values: */</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment">/*   MZ_OK on success. Either more input is needed but not available, and/or there&#39;s more output to be written but the output buffer is full. */</span></div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment">/*   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. */</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment">/*   MZ_STREAM_ERROR if the stream is bogus. */</span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment">/*   MZ_DATA_ERROR if the deflate stream is invalid. */</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment">/*   MZ_PARAM_ERROR if one of the parameters is invalid. */</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment">/*   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again */</span></div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment">/*   with more input data, or with more room in the output buffer (except when using single call decompression, described above). */</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="keywordtype">int</span> mz_inflate(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream, <span class="keywordtype">int</span> flush);</div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span> </div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment">/* Deinitializes a decompressor. */</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="keywordtype">int</span> mz_inflateEnd(<a class="code hl_struct" href="structmz__stream__s.html">mz_streamp</a> pStream);</div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span> </div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment">/* Single-call decompression. */</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment">/* Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. */</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="keywordtype">int</span> mz_uncompress(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pDest, mz_ulong *pDest_len, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pSource, mz_ulong source_len);</div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span> </div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment">/* Returns a string description of the specified error code, or NULL if the error code is invalid. */</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="keyword">const</span> <span class="keywordtype">char</span> *mz_error(<span class="keywordtype">int</span> err);</div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span> </div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment">/* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment">/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="preprocessor">#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Byte;</div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uInt;</div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span><span class="keyword">typedef</span> mz_ulong uLong;</div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="keyword">typedef</span> Byte Bytef;</div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="keyword">typedef</span> uInt uIntf;</div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span><span class="keyword">typedef</span> <span class="keywordtype">char</span> charf;</div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="keyword">typedef</span> <span class="keywordtype">int</span> intf;</div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *voidpf;</div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="keyword">typedef</span> uLong uLongf;</div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *voidp;</div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *<span class="keyword">const</span> voidpc;</div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="preprocessor">#define Z_NULL 0</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="preprocessor">#define Z_NO_FLUSH MZ_NO_FLUSH</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="preprocessor">#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="preprocessor">#define Z_SYNC_FLUSH MZ_SYNC_FLUSH</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="preprocessor">#define Z_FULL_FLUSH MZ_FULL_FLUSH</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="preprocessor">#define Z_FINISH MZ_FINISH</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="preprocessor">#define Z_BLOCK MZ_BLOCK</span></div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span><span class="preprocessor">#define Z_OK MZ_OK</span></div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span><span class="preprocessor">#define Z_STREAM_END MZ_STREAM_END</span></div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span><span class="preprocessor">#define Z_NEED_DICT MZ_NEED_DICT</span></div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span><span class="preprocessor">#define Z_ERRNO MZ_ERRNO</span></div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span><span class="preprocessor">#define Z_STREAM_ERROR MZ_STREAM_ERROR</span></div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span><span class="preprocessor">#define Z_DATA_ERROR MZ_DATA_ERROR</span></div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span><span class="preprocessor">#define Z_MEM_ERROR MZ_MEM_ERROR</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="preprocessor">#define Z_BUF_ERROR MZ_BUF_ERROR</span></div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span><span class="preprocessor">#define Z_VERSION_ERROR MZ_VERSION_ERROR</span></div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="preprocessor">#define Z_PARAM_ERROR MZ_PARAM_ERROR</span></div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span><span class="preprocessor">#define Z_NO_COMPRESSION MZ_NO_COMPRESSION</span></div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span><span class="preprocessor">#define Z_BEST_SPEED MZ_BEST_SPEED</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span><span class="preprocessor">#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION</span></div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="preprocessor">#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION</span></div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="preprocessor">#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span><span class="preprocessor">#define Z_FILTERED MZ_FILTERED</span></div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span><span class="preprocessor">#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY</span></div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="preprocessor">#define Z_RLE MZ_RLE</span></div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="preprocessor">#define Z_FIXED MZ_FIXED</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="preprocessor">#define Z_DEFLATED MZ_DEFLATED</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="preprocessor">#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span><span class="preprocessor">#define alloc_func mz_alloc_func</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="preprocessor">#define free_func mz_free_func</span></div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span><span class="preprocessor">#define internal_state mz_internal_state</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span><span class="preprocessor">#define z_stream mz_stream</span></div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span><span class="preprocessor">#define deflateInit mz_deflateInit</span></div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span><span class="preprocessor">#define deflateInit2 mz_deflateInit2</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span><span class="preprocessor">#define deflateReset mz_deflateReset</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span><span class="preprocessor">#define deflate mz_deflate</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="preprocessor">#define deflateEnd mz_deflateEnd</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="preprocessor">#define deflateBound mz_deflateBound</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="preprocessor">#define compress mz_compress</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="preprocessor">#define compress2 mz_compress2</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="preprocessor">#define compressBound mz_compressBound</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="preprocessor">#define inflateInit mz_inflateInit</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="preprocessor">#define inflateInit2 mz_inflateInit2</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="preprocessor">#define inflateReset mz_inflateReset</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span><span class="preprocessor">#define inflate mz_inflate</span></div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span><span class="preprocessor">#define inflateEnd mz_inflateEnd</span></div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span><span class="preprocessor">#define uncompress mz_uncompress</span></div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span><span class="preprocessor">#define crc32 mz_crc32</span></div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="preprocessor">#define adler32 mz_adler32</span></div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span><span class="preprocessor">#define MAX_WBITS 15</span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span><span class="preprocessor">#define MAX_MEM_LEVEL 9</span></div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="preprocessor">#define zError mz_error</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="preprocessor">#define ZLIB_VERSION MZ_VERSION</span></div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="preprocessor">#define ZLIB_VERNUM MZ_VERNUM</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span><span class="preprocessor">#define ZLIB_VER_MAJOR MZ_VER_MAJOR</span></div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="preprocessor">#define ZLIB_VER_MINOR MZ_VER_MINOR</span></div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="preprocessor">#define ZLIB_VER_REVISION MZ_VER_REVISION</span></div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="preprocessor">#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span><span class="preprocessor">#define zlibVersion mz_version</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span><span class="preprocessor">#define zlib_version mz_version()</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span><span class="preprocessor">#endif </span><span class="comment">/* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */</span><span class="preprocessor"></span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span> </div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span><span class="preprocessor">#endif </span><span class="comment">/* MINIZ_NO_ZLIB_APIS */</span><span class="preprocessor"></span></div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span> </div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span>}</div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span> </div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment">/* ------------------- Types and macros */</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mz_uint8;</div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span><span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">short</span> mz_int16;</div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> mz_uint16;</div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mz_uint32;</div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mz_uint;</div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span><span class="keyword">typedef</span> int64_t mz_int64;</div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span><span class="keyword">typedef</span> uint64_t mz_uint64;</div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span><span class="keyword">typedef</span> <span class="keywordtype">int</span> mz_bool;</div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span> </div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="preprocessor">#define MZ_FALSE (0)</span></div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="preprocessor">#define MZ_TRUE (1)</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span> </div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment">/* Works around MSVC&#39;s spammy &quot;warning C4127: conditional expression is constant&quot; message. */</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="preprocessor">#ifdef _MSC_VER</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span><span class="preprocessor">#define MZ_MACRO_END while (0, 0)</span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span><span class="preprocessor">#define MZ_MACRO_END while (0)</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span> </div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="preprocessor">#ifdef MINIZ_NO_STDIO</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span><span class="preprocessor">#define MZ_FILE void *</span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="preprocessor">#define MZ_FILE FILE</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="preprocessor">#endif </span><span class="comment">/* #ifdef MINIZ_NO_STDIO */</span><span class="preprocessor"></span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span> </div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="preprocessor">#ifdef MINIZ_NO_TIME</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno"><a class="line" href="structmz__dummy__time__t__tag.html">  512</a></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structmz__dummy__time__t__tag.html">mz_dummy_time_t_tag</a></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span>{</div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>    <span class="keywordtype">int</span> m_dummy;</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span>} <a class="code hl_struct" href="structmz__dummy__time__t__tag.html">mz_dummy_time_t</a>;</div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span><span class="preprocessor">#define MZ_TIME_T mz_dummy_time_t</span></div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span><span class="preprocessor">#define MZ_TIME_T time_t</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span> </div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="preprocessor">#define MZ_ASSERT(x) assert(x)</span></div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span> </div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="preprocessor">#ifdef MINIZ_NO_MALLOC</span></div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span><span class="preprocessor">#define MZ_MALLOC(x) NULL</span></div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="preprocessor">#define MZ_FREE(x) (void)x, ((void)0)</span></div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="preprocessor">#define MZ_REALLOC(p, x) NULL</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="preprocessor">#define MZ_MALLOC(x) malloc(x)</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span><span class="preprocessor">#define MZ_FREE(x) free(x)</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span><span class="preprocessor">#define MZ_REALLOC(p, x) realloc(p, x)</span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span> </div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span><span class="preprocessor">#define MZ_MAX(a, b) (((a) &gt; (b)) ? (a) : (b))</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span><span class="preprocessor">#define MZ_MIN(a, b) (((a) &lt; (b)) ? (a) : (b))</span></div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span><span class="preprocessor">#define MZ_CLEAR_OBJ(obj) memset(&amp;(obj), 0, sizeof(obj))</span></div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span> </div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span><span class="preprocessor">#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES &amp;&amp; MINIZ_LITTLE_ENDIAN</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span><span class="preprocessor">#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))</span></div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span><span class="preprocessor">#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))</span></div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span><span class="preprocessor">#define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) &lt;&lt; 8U))</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span><span class="preprocessor">#define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) &lt;&lt; 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) &lt;&lt; 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) &lt;&lt; 24U))</span></div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span> </div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="preprocessor">#define MZ_READ_LE64(p) (((mz_uint64)MZ_READ_LE32(p)) | (((mz_uint64)MZ_READ_LE32((const mz_uint8 *)(p) + sizeof(mz_uint32))) &lt;&lt; 32U))</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span> </div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span><span class="preprocessor">#ifdef _MSC_VER</span></div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span><span class="preprocessor">#define MZ_FORCEINLINE __forceinline</span></div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span><span class="preprocessor">#elif defined(__GNUC__)</span></div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span><span class="preprocessor">#define MZ_FORCEINLINE __inline__ __attribute__((__always_inline__))</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span><span class="preprocessor">#define MZ_FORCEINLINE inline</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span> </div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span> </div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="keyword">extern</span> <span class="keywordtype">void</span> *miniz_def_alloc_func(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">size_t</span> items, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="keyword">extern</span> <span class="keywordtype">void</span> miniz_def_free_func(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">void</span> *address);</div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="keyword">extern</span> <span class="keywordtype">void</span> *miniz_def_realloc_func(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">void</span> *address, <span class="keywordtype">size_t</span> items, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span> </div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span><span class="preprocessor">#define MZ_UINT16_MAX (0xFFFFU)</span></div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span><span class="preprocessor">#define MZ_UINT32_MAX (0xFFFFFFFFU)</span></div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span> </div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>}</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span> </div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span> </div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span><span class="comment">/* ------------------- Low-level Compression API Definitions */</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span> </div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span><span class="comment">/* Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently). */</span></div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="preprocessor">#define TDEFL_LESS_MEMORY 0</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span> </div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment">/* tdefl_init() compression flags logically OR&#39;d together (low 12 bits contain the max. number of probes per dictionary search): */</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment">/* TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). */</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span>{</div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>    TDEFL_HUFFMAN_ONLY = 0,</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span>    TDEFL_DEFAULT_MAX_PROBES = 128,</div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>    TDEFL_MAX_PROBES_MASK = 0xFFF</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>};</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span> </div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment">/* TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you&#39;ll get raw deflate data. */</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment">/* TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). */</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="comment">/* TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. */</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment">/* TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor&#39;s initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). */</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment">/* TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) */</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="comment">/* TDEFL_FILTER_MATCHES: Discards matches &lt;= 5 chars if enabled. */</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment">/* TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. */</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span><span class="comment">/* TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. */</span></div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span><span class="comment">/* The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). */</span></div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span>{</div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span>    TDEFL_WRITE_ZLIB_HEADER = 0x01000,</div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span>    TDEFL_COMPUTE_ADLER32 = 0x02000,</div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span>    TDEFL_GREEDY_PARSING_FLAG = 0x04000,</div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span>    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,</div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span>    TDEFL_RLE_MATCHES = 0x10000,</div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span>    TDEFL_FILTER_MATCHES = 0x20000,</div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span>    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,</div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span>    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000</div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span>};</div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span> </div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span><span class="comment">/* High level compression functions: */</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span><span class="comment">/* tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). */</span></div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span><span class="comment">/* On entry: */</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span><span class="comment">/*  pSrc_buf, src_buf_len: Pointer and size of source block to compress. */</span></div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span><span class="comment">/*  flags: The max match finder probes (default is 128) logically OR&#39;d against the above flags. Higher probes are slower but improve compression. */</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span><span class="comment">/* On return: */</span></div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span><span class="comment">/*  Function returns a pointer to the compressed data, or NULL on failure. */</span></div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span><span class="comment">/*  *pOut_len will be set to the compressed data&#39;s size, which could be larger than src_buf_len on uncompressible data. */</span></div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span><span class="comment">/*  The caller must free() the returned block when it&#39;s no longer needed. */</span></div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span><span class="keywordtype">void</span> *tdefl_compress_mem_to_heap(<span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">size_t</span> *pOut_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span> </div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span><span class="comment">/* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */</span></div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span><span class="comment">/* Returns 0 on failure. */</span></div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span><span class="keywordtype">size_t</span> tdefl_compress_mem_to_mem(<span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> out_buf_len, <span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span> </div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span><span class="comment">/* Compresses an image to a compressed PNG file in memory. */</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span><span class="comment">/* On entry: */</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span><span class="comment">/*  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. */</span></div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span><span class="comment">/*  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. */</span></div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span><span class="comment">/*  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL */</span></div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span><span class="comment">/*  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). */</span></div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span><span class="comment">/* On return: */</span></div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span><span class="comment">/*  Function returns a pointer to the compressed data, or NULL on failure. */</span></div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span><span class="comment">/*  *pLen_out will be set to the size of the PNG image file. */</span></div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span><span class="comment">/*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it&#39;s no longer needed. */</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><span class="keywordtype">void</span> *tdefl_write_image_to_png_file_in_memory_ex(<span class="keyword">const</span> <span class="keywordtype">void</span> *pImage, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> num_chans, <span class="keywordtype">size_t</span> *pLen_out, mz_uint level, mz_bool flip);</div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span><span class="keywordtype">void</span> *tdefl_write_image_to_png_file_in_memory(<span class="keyword">const</span> <span class="keywordtype">void</span> *pImage, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> num_chans, <span class="keywordtype">size_t</span> *pLen_out);</div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span> </div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span><span class="comment">/* Output stream interface. The compressor uses this interface to write compressed data. It&#39;ll typically be called TDEFL_OUT_BUF_SIZE at a time. */</span></div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span><span class="keyword">typedef</span> mz_bool (*tdefl_put_buf_func_ptr)(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *pUser);</div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span> </div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span><span class="comment">/* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */</span></div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span>mz_bool tdefl_compress_mem_to_output(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_len, tdefl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span> </div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span>{</div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span>    TDEFL_MAX_HUFF_TABLES = 3,</div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span>    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,</div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span>    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,</div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span>    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,</div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span>    TDEFL_LZ_DICT_SIZE = 32768,</div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span>    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,</div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span>    TDEFL_MIN_MATCH_LEN = 3,</div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span>    TDEFL_MAX_MATCH_LEN = 258</div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span>};</div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span> </div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span><span class="comment">/* TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes). */</span></div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span><span class="preprocessor">#if TDEFL_LESS_MEMORY</span></div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span>{</div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span>    TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,</div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span>    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,</div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span>    TDEFL_MAX_HUFF_SYMBOLS = 288,</div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span>    TDEFL_LZ_HASH_BITS = 12,</div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span>    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,</div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span>    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,</div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span>    TDEFL_LZ_HASH_SIZE = 1 &lt;&lt; TDEFL_LZ_HASH_BITS</div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span>};</div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span>{</div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span>    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,</div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span>    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,</div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span>    TDEFL_MAX_HUFF_SYMBOLS = 288,</div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span>    TDEFL_LZ_HASH_BITS = 15,</div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span>    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,</div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span>    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,</div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span>    TDEFL_LZ_HASH_SIZE = 1 &lt;&lt; TDEFL_LZ_HASH_BITS</div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span>};</div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span> </div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span><span class="comment">/* The low-level tdefl functions below may be used directly if the above helper functions aren&#39;t flexible enough. The low-level functions don&#39;t make any heap allocations, unlike the above helper functions. */</span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span>    TDEFL_STATUS_BAD_PARAM = -2,</div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span>    TDEFL_STATUS_PUT_BUF_FAILED = -1,</div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span>    TDEFL_STATUS_OKAY = 0,</div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span>    TDEFL_STATUS_DONE = 1</div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span>} tdefl_status;</div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span> </div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span><span class="comment">/* Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums */</span></div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span>    TDEFL_NO_FLUSH = 0,</div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span>    TDEFL_SYNC_FLUSH = 2,</div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span>    TDEFL_FULL_FLUSH = 3,</div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span>    TDEFL_FINISH = 4</div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span>} tdefl_flush;</div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span> </div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span><span class="comment">/* tdefl&#39;s compression state structure. */</span></div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno"><a class="line" href="structtdefl__compressor.html">  698</a></span><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span>{</div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span>    tdefl_put_buf_func_ptr m_pPut_buf_func;</div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span>    <span class="keywordtype">void</span> *m_pPut_buf_user;</div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span>    mz_uint m_flags, m_max_probes[2];</div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span>    <span class="keywordtype">int</span> m_greedy_parsing;</div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span>    mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;</div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span>    mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;</div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span>    mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;</div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span>    mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;</div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span>    tdefl_status m_prev_return_status;</div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span>    <span class="keyword">const</span> <span class="keywordtype">void</span> *m_pIn_buf;</div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span>    <span class="keywordtype">void</span> *m_pOut_buf;</div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span>    <span class="keywordtype">size_t</span> *m_pIn_buf_size, *m_pOut_buf_size;</div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span>    tdefl_flush m_flush;</div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span>    <span class="keyword">const</span> mz_uint8 *m_pSrc;</div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span>    <span class="keywordtype">size_t</span> m_src_buf_left, m_out_buf_ofs;</div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span>    mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];</div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span>    mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];</div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span>    mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];</div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span>    mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];</div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span>    mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];</div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span>    mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];</div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span>    mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];</div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span>    mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];</div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span>} <a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a>;</div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span> </div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span><span class="comment">/* Initializes the compressor. */</span></div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span><span class="comment">/* There is no corresponding deinit() function because the tdefl API&#39;s do not dynamically allocate memory. */</span></div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span><span class="comment">/* pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. */</span></div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span><span class="comment">/* If pBut_buf_func is NULL the user should always call the tdefl_compress() API. */</span></div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span><span class="comment">/* flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) */</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span>tdefl_status tdefl_init(<a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *d, tdefl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span> </div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span><span class="comment">/* Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. */</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span>tdefl_status tdefl_compress(<a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *d, <span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> *pIn_buf_size, <span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> *pOut_buf_size, tdefl_flush flush);</div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span> </div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment">/* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span><span class="comment">/* tdefl_compress_buffer() always consumes the entire input buffer. */</span></div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span>tdefl_status tdefl_compress_buffer(<a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *d, <span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> in_buf_size, tdefl_flush flush);</div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span> </div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span>tdefl_status tdefl_get_prev_return_status(<a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *d);</div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span>mz_uint32 tdefl_get_adler32(<a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *d);</div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span> </div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span><span class="comment">/* Create tdefl_compress() flags given zlib-style compression parameters. */</span></div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span><span class="comment">/* level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) */</span></div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span><span class="comment">/* window_bits may be -15 (raw deflate) or 15 (zlib) */</span></div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span><span class="comment">/* strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED */</span></div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span>mz_uint tdefl_create_comp_flags_from_zip_params(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> window_bits, <span class="keywordtype">int</span> strategy);</div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span> </div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span><span class="preprocessor">#ifndef MINIZ_NO_MALLOC</span></div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span><span class="comment">/* Allocate the tdefl_compressor structure in C so that */</span></div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span><span class="comment">/* non-C language bindings to tdefl_ API don&#39;t need to worry about */</span></div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span><span class="comment">/* structure size and allocation mechanism. */</span></div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span><a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *tdefl_compressor_alloc(<span class="keywordtype">void</span>);</div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span><span class="keywordtype">void</span> tdefl_compressor_free(<a class="code hl_struct" href="structtdefl__compressor.html">tdefl_compressor</a> *pComp);</div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span> </div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span>}</div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span> </div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span><span class="comment">/* ------------------- Low-level Decompression API Definitions */</span></div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span> </div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span><span class="comment">/* Decompression flags used by tinfl_decompress(). */</span></div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span><span class="comment">/* TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it&#39;s a valid zlib stream). Otherwise, the input is a raw deflate stream. */</span></div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span><span class="comment">/* TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. */</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span><span class="comment">/* TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). */</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span><span class="comment">/* TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. */</span></div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span>{</div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span>    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,</div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span>    TINFL_FLAG_HAS_MORE_INPUT = 2,</div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span>    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,</div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span>    TINFL_FLAG_COMPUTE_ADLER32 = 8</div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span>};</div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span> </div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span><span class="comment">/* High level decompression functions: */</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span><span class="comment">/* tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). */</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment">/* On entry: */</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span><span class="comment">/*  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. */</span></div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span><span class="comment">/* On return: */</span></div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span><span class="comment">/*  Function returns a pointer to the decompressed data, or NULL on failure. */</span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span><span class="comment">/*  *pOut_len will be set to the decompressed data&#39;s size, which could be larger than src_buf_len on uncompressible data. */</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment">/*  The caller must call mz_free() on the returned block when it&#39;s no longer needed. */</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span><span class="keywordtype">void</span> *tinfl_decompress_mem_to_heap(<span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">size_t</span> *pOut_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span> </div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span><span class="comment">/* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */</span></div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span><span class="comment">/* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */</span></div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span><span class="preprocessor">#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))</span></div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span><span class="keywordtype">size_t</span> tinfl_decompress_mem_to_mem(<span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> out_buf_len, <span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span> </div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span><span class="comment">/* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */</span></div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span><span class="comment">/* Returns 1 on success or 0 on failure. */</span></div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span><span class="keyword">typedef</span> int (*tinfl_put_buf_func_ptr)(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *pUser);</div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span><span class="keywordtype">int</span> tinfl_decompress_mem_to_callback(<span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span> </div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span><span class="keyword">struct </span><a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor_tag</a>;</div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor_tag</a> <a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor</a>;</div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span> </div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span><span class="preprocessor">#ifndef MINIZ_NO_MALLOC</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span><span class="comment">/* Allocate the tinfl_decompressor structure in C so that */</span></div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span><span class="comment">/* non-C language bindings to tinfl_ API don&#39;t need to worry about */</span></div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span><span class="comment">/* structure size and allocation mechanism. */</span></div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span><a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor</a> *tinfl_decompressor_alloc(<span class="keywordtype">void</span>);</div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span><span class="keywordtype">void</span> tinfl_decompressor_free(<a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor</a> *pDecomp);</div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span> </div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span><span class="comment">/* Max size of LZ dictionary. */</span></div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span><span class="preprocessor">#define TINFL_LZ_DICT_SIZE 32768</span></div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span> </div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span><span class="comment">/* Return status. */</span></div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span>    <span class="comment">/* This flags indicates the inflator needs 1 or more input bytes to make forward progress, but the caller is indicating that no more are available. The compressed data */</span></div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span>    <span class="comment">/* is probably corrupted. If you call the inflator again with more bytes it&#39;ll try to continue processing the input but this is a BAD sign (either the data is corrupted or you called it incorrectly). */</span></div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span>    <span class="comment">/* If you call it again with no input you&#39;ll just get TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS again. */</span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span>    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,</div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span> </div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span>    <span class="comment">/* This flag indicates that one or more of the input parameters was obviously bogus. (You can try calling it again, but if you get this error the calling code is wrong.) */</span></div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span>    TINFL_STATUS_BAD_PARAM = -3,</div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span> </div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span>    <span class="comment">/* This flags indicate the inflator is finished but the adler32 check of the uncompressed data didn&#39;t match. If you call it again it&#39;ll return TINFL_STATUS_DONE. */</span></div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span>    TINFL_STATUS_ADLER32_MISMATCH = -2,</div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span> </div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span>    <span class="comment">/* This flags indicate the inflator has somehow failed (bad code, corrupted input, etc.). If you call it again without resetting via tinfl_init() it it&#39;ll just keep on returning the same status failure code. */</span></div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span>    TINFL_STATUS_FAILED = -1,</div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span> </div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span>    <span class="comment">/* Any status code less than TINFL_STATUS_DONE must indicate a failure. */</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span> </div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span>    <span class="comment">/* This flag indicates the inflator has returned every byte of uncompressed data that it can, has consumed every byte that it needed, has successfully reached the end of the deflate stream, and */</span></div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span>    <span class="comment">/* if zlib headers and adler32 checking enabled that it has successfully checked the uncompressed data&#39;s adler32. If you call it again you&#39;ll just get TINFL_STATUS_DONE over and over again. */</span></div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span>    TINFL_STATUS_DONE = 0,</div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span> </div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span>    <span class="comment">/* This flag indicates the inflator MUST have more input data (even 1 byte) before it can make any more forward progress, or you need to clear the TINFL_FLAG_HAS_MORE_INPUT */</span></div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span>    <span class="comment">/* flag on the next call if you don&#39;t have any more source data. If the source data was somehow corrupted it&#39;s also possible (but unlikely) for the inflator to keep on demanding input to */</span></div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span>    <span class="comment">/* proceed, so be sure to properly set the TINFL_FLAG_HAS_MORE_INPUT flag. */</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span>    TINFL_STATUS_NEEDS_MORE_INPUT = 1,</div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span> </div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span>    <span class="comment">/* This flag indicates the inflator definitely has 1 or more bytes of uncompressed data available, but it cannot write this data into the output buffer. */</span></div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span>    <span class="comment">/* Note if the source compressed data was corrupted it&#39;s possible for the inflator to return a lot of uncompressed data to the caller. I&#39;ve been assuming you know how much uncompressed data to expect */</span></div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span>    <span class="comment">/* (either exact or worst case) and will stop calling the inflator and fail after receiving too much. In pure streaming scenarios where you have no idea how many bytes to expect this may not be possible */</span></div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span>    <span class="comment">/* so I may need to add some code to address this. */</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span>    TINFL_STATUS_HAS_MORE_OUTPUT = 2</div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span>} tinfl_status;</div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span> </div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span><span class="comment">/* Initializes the decompressor to its initial state. */</span></div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span><span class="preprocessor">#define tinfl_init(r)     \</span></div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span><span class="preprocessor">    do                    \</span></div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span><span class="preprocessor">    {                     \</span></div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span><span class="preprocessor">        (r)-&gt;m_state = 0; \</span></div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno">  852</span><span class="preprocessor">    }                     \</span></div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno">  853</span><span class="preprocessor">    MZ_MACRO_END</span></div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno">  854</span><span class="preprocessor">#define tinfl_get_adler32(r) (r)-&gt;m_check_adler32</span></div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span> </div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span><span class="comment">/* Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. */</span></div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span><span class="comment">/* This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. */</span></div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span>tinfl_status tinfl_decompress(<a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor</a> *r, <span class="keyword">const</span> mz_uint8 *pIn_buf_next, <span class="keywordtype">size_t</span> *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, <span class="keywordtype">size_t</span> *pOut_buf_size, <span class="keyword">const</span> mz_uint32 decomp_flags);</div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span> </div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span><span class="comment">/* Internal/private bits follow. */</span></div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span>{</div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span>    TINFL_MAX_HUFF_TABLES = 3,</div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span>    TINFL_MAX_HUFF_SYMBOLS_0 = 288,</div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span>    TINFL_MAX_HUFF_SYMBOLS_1 = 32,</div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span>    TINFL_MAX_HUFF_SYMBOLS_2 = 19,</div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span>    TINFL_FAST_LOOKUP_BITS = 10,</div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span>    TINFL_FAST_LOOKUP_SIZE = 1 &lt;&lt; TINFL_FAST_LOOKUP_BITS</div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span>};</div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span> </div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno"><a class="line" href="structtinfl__huff__table.html">  871</a></span><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>{</div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>    mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];</div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span>    mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];</div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span>} <a class="code hl_struct" href="structtinfl__huff__table.html">tinfl_huff_table</a>;</div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span> </div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span><span class="preprocessor">#if MINIZ_HAS_64BIT_REGISTERS</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span><span class="preprocessor">#define TINFL_USE_64BIT_BITBUF 1</span></div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span><span class="preprocessor">#define TINFL_USE_64BIT_BITBUF 0</span></div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span> </div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span><span class="preprocessor">#if TINFL_USE_64BIT_BITBUF</span></div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span><span class="keyword">typedef</span> mz_uint64 tinfl_bit_buf_t;</div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span><span class="preprocessor">#define TINFL_BITBUF_SIZE (64)</span></div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span><span class="keyword">typedef</span> mz_uint32 tinfl_bit_buf_t;</div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span><span class="preprocessor">#define TINFL_BITBUF_SIZE (32)</span></div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span> </div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno"><a class="line" href="structtinfl__decompressor__tag.html">  891</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor_tag</a></div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span>{</div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span>    mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];</div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span>    tinfl_bit_buf_t m_bit_buf;</div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span>    <span class="keywordtype">size_t</span> m_dist_from_out_buf_start;</div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span>    <a class="code hl_struct" href="structtinfl__huff__table.html">tinfl_huff_table</a> m_tables[TINFL_MAX_HUFF_TABLES];</div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span>    mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];</div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span>};</div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span> </div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span>}</div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span> </div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span> </div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span> </div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span><span class="comment">/* ------------------- ZIP archive reading/writing */</span></div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span> </div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span><span class="preprocessor">#ifndef MINIZ_NO_ARCHIVE_APIS</span></div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span> </div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span> </div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span><span class="keyword">enum</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span>{</div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span>    <span class="comment">/* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */</span></div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span>    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,</div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span>    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,</div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span>    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512</div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span>};</div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span> </div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno"><a class="line" href="structmz__zip__archive__file__stat.html">  923</a></span><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span>{</div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span>    <span class="comment">/* Central directory file index. */</span></div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span>    mz_uint32 m_file_index;</div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span> </div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span>    <span class="comment">/* Byte offset of this entry in the archive&#39;s central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */</span></div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span>    mz_uint64 m_central_dir_ofs;</div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span> </div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span>    <span class="comment">/* These fields are copied directly from the zip&#39;s central dir. */</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span>    mz_uint16 m_version_made_by;</div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span>    mz_uint16 m_version_needed;</div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span>    mz_uint16 m_bit_flag;</div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span>    mz_uint16 m_method;</div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span> </div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span><span class="preprocessor">#ifndef MINIZ_NO_TIME</span></div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span>    MZ_TIME_T m_time;</div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span> </div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span>    <span class="comment">/* CRC-32 of uncompressed data. */</span></div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span>    mz_uint32 m_crc32;</div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span> </div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span>    <span class="comment">/* File&#39;s compressed size. */</span></div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span>    mz_uint64 m_comp_size;</div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span> </div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span>    <span class="comment">/* File&#39;s uncompressed size. Note, I&#39;ve seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */</span></div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span>    mz_uint64 m_uncomp_size;</div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span> </div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span>    <span class="comment">/* Zip internal and external file attributes. */</span></div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span>    mz_uint16 m_internal_attr;</div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span>    mz_uint32 m_external_attr;</div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span> </div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span>    <span class="comment">/* Entry&#39;s local header file offset in bytes. */</span></div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span>    mz_uint64 m_local_header_ofs;</div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span> </div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span>    <span class="comment">/* Size of comment in bytes. */</span></div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span>    mz_uint32 m_comment_size;</div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span> </div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span>    <span class="comment">/* MZ_TRUE if the entry appears to be a directory. */</span></div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span>    mz_bool m_is_directory;</div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span> </div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span>    <span class="comment">/* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn&#39;t support) */</span></div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span>    mz_bool m_is_encrypted;</div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span> </div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>    <span class="comment">/* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */</span></div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span>    mz_bool m_is_supported;</div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span> </div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span>    <span class="comment">/* Filename. If string ends in &#39;/&#39; it&#39;s a subdirectory entry. */</span></div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span>    <span class="comment">/* Guaranteed to be zero terminated, may be truncated to fit. */</span></div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span>    <span class="keywordtype">char</span> m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];</div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span> </div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span>    <span class="comment">/* Comment field. */</span></div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span>    <span class="comment">/* Guaranteed to be zero terminated, may be truncated to fit. */</span></div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span>    <span class="keywordtype">char</span> m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];</div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span> </div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span>} <a class="code hl_struct" href="structmz__zip__archive__file__stat.html">mz_zip_archive_file_stat</a>;</div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span> </div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span><span class="keyword">typedef</span> size_t (*mz_file_read_func)(<span class="keywordtype">void</span> *pOpaque, mz_uint64 file_ofs, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> n);</div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span><span class="keyword">typedef</span> size_t (*mz_file_write_func)(<span class="keywordtype">void</span> *pOpaque, mz_uint64 file_ofs, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> n);</div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span><span class="keyword">typedef</span> mz_bool (*mz_file_needs_keepalive)(<span class="keywordtype">void</span> *pOpaque);</div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno">  982</span> </div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span><span class="keyword">struct </span><a class="code hl_struct" href="structmz__zip__internal__state__tag.html">mz_zip_internal_state_tag</a>;</div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structmz__zip__internal__state__tag.html">mz_zip_internal_state_tag</a> <a class="code hl_struct" href="structmz__zip__internal__state__tag.html">mz_zip_internal_state</a>;</div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span> </div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span>    MZ_ZIP_MODE_INVALID = 0,</div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span>    MZ_ZIP_MODE_READING = 1,</div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span>    MZ_ZIP_MODE_WRITING = 2,</div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span>    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3</div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span>} mz_zip_mode;</div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span> </div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span>    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,</div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno">  995</span>    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,</div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno">  996</span>    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,</div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno">  997</span>    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,</div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno">  998</span>    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, <span class="comment">/* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */</span></div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span>    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     <span class="comment">/* validate the local headers, but don&#39;t decompress the entire file and check the crc32 */</span></div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span>    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               <span class="comment">/* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */</span></div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span>    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,</div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span>    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000</div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span>} mz_zip_flags;</div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span> </div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span>    MZ_ZIP_TYPE_INVALID = 0,</div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span>    MZ_ZIP_TYPE_USER,</div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span>    MZ_ZIP_TYPE_MEMORY,</div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"> 1009</span>    MZ_ZIP_TYPE_HEAP,</div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"> 1010</span>    MZ_ZIP_TYPE_FILE,</div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"> 1011</span>    MZ_ZIP_TYPE_CFILE,</div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"> 1012</span>    MZ_ZIP_TOTAL_TYPES</div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span>} mz_zip_type;</div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span> </div>
<div class="line"><a id="l01015" name="l01015"></a><span class="lineno"> 1015</span><span class="comment">/* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */</span></div>
<div class="line"><a id="l01016" name="l01016"></a><span class="lineno"> 1016</span><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line"><a id="l01017" name="l01017"></a><span class="lineno"> 1017</span>    MZ_ZIP_NO_ERROR = 0,</div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span>    MZ_ZIP_UNDEFINED_ERROR,</div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span>    MZ_ZIP_TOO_MANY_FILES,</div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span>    MZ_ZIP_FILE_TOO_LARGE,</div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span>    MZ_ZIP_UNSUPPORTED_METHOD,</div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span>    MZ_ZIP_UNSUPPORTED_ENCRYPTION,</div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span>    MZ_ZIP_UNSUPPORTED_FEATURE,</div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span>    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,</div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span>    MZ_ZIP_NOT_AN_ARCHIVE,</div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"> 1026</span>    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,</div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"> 1027</span>    MZ_ZIP_UNSUPPORTED_MULTIDISK,</div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"> 1028</span>    MZ_ZIP_DECOMPRESSION_FAILED,</div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"> 1029</span>    MZ_ZIP_COMPRESSION_FAILED,</div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span>    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,</div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span>    MZ_ZIP_CRC_CHECK_FAILED,</div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span>    MZ_ZIP_UNSUPPORTED_CDIR_SIZE,</div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span>    MZ_ZIP_ALLOC_FAILED,</div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span>    MZ_ZIP_FILE_OPEN_FAILED,</div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span>    MZ_ZIP_FILE_CREATE_FAILED,</div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span>    MZ_ZIP_FILE_WRITE_FAILED,</div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span>    MZ_ZIP_FILE_READ_FAILED,</div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"> 1038</span>    MZ_ZIP_FILE_CLOSE_FAILED,</div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span>    MZ_ZIP_FILE_SEEK_FAILED,</div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span>    MZ_ZIP_FILE_STAT_FAILED,</div>
<div class="line"><a id="l01041" name="l01041"></a><span class="lineno"> 1041</span>    MZ_ZIP_INVALID_PARAMETER,</div>
<div class="line"><a id="l01042" name="l01042"></a><span class="lineno"> 1042</span>    MZ_ZIP_INVALID_FILENAME,</div>
<div class="line"><a id="l01043" name="l01043"></a><span class="lineno"> 1043</span>    MZ_ZIP_BUF_TOO_SMALL,</div>
<div class="line"><a id="l01044" name="l01044"></a><span class="lineno"> 1044</span>    MZ_ZIP_INTERNAL_ERROR,</div>
<div class="line"><a id="l01045" name="l01045"></a><span class="lineno"> 1045</span>    MZ_ZIP_FILE_NOT_FOUND,</div>
<div class="line"><a id="l01046" name="l01046"></a><span class="lineno"> 1046</span>    MZ_ZIP_ARCHIVE_TOO_LARGE,</div>
<div class="line"><a id="l01047" name="l01047"></a><span class="lineno"> 1047</span>    MZ_ZIP_VALIDATION_FAILED,</div>
<div class="line"><a id="l01048" name="l01048"></a><span class="lineno"> 1048</span>    MZ_ZIP_WRITE_CALLBACK_FAILED,</div>
<div class="line"><a id="l01049" name="l01049"></a><span class="lineno"> 1049</span>    MZ_ZIP_TOTAL_ERRORS</div>
<div class="line"><a id="l01050" name="l01050"></a><span class="lineno"> 1050</span>} mz_zip_error;</div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span> </div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"><a class="line" href="structmz__zip__archive.html"> 1052</a></span><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"> 1053</span>{</div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span>    mz_uint64 m_archive_size;</div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span>    mz_uint64 m_central_directory_file_ofs;</div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span> </div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span>    <span class="comment">/* We only support up to UINT32_MAX files in zip64 mode. */</span></div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span>    mz_uint32 m_total_files;</div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span>    mz_zip_mode m_zip_mode;</div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span>    mz_zip_type m_zip_type;</div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"> 1061</span>    mz_zip_error m_last_error;</div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"> 1062</span> </div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"> 1063</span>    mz_uint64 m_file_offset_alignment;</div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span> </div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span>    mz_alloc_func m_pAlloc;</div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span>    mz_free_func m_pFree;</div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"> 1067</span>    mz_realloc_func m_pRealloc;</div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span>    <span class="keywordtype">void</span> *m_pAlloc_opaque;</div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span> </div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"> 1070</span>    mz_file_read_func m_pRead;</div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span>    mz_file_write_func m_pWrite;</div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span>    mz_file_needs_keepalive m_pNeeds_keepalive;</div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span>    <span class="keywordtype">void</span> *m_pIO_opaque;</div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span> </div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"> 1075</span>    <a class="code hl_struct" href="structmz__zip__internal__state__tag.html">mz_zip_internal_state</a> *m_pState;</div>
<div class="line"><a id="l01076" name="l01076"></a><span class="lineno"> 1076</span> </div>
<div class="line"><a id="l01077" name="l01077"></a><span class="lineno"> 1077</span>} <a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a>;</div>
<div class="line"><a id="l01078" name="l01078"></a><span class="lineno"> 1078</span> </div>
<div class="line"><a id="l01079" name="l01079"></a><span class="lineno"><a class="line" href="structmz__zip__reader__extract__iter__state.html"> 1079</a></span><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a id="l01080" name="l01080"></a><span class="lineno"> 1080</span>{</div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"> 1081</span>    <a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip;</div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span>    mz_uint flags;</div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span> </div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"> 1084</span>    <span class="keywordtype">int</span> status;</div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span><span class="preprocessor">#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS</span></div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span>    mz_uint file_crc32;</div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"> 1087</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span>    mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;</div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"> 1089</span>    <a class="code hl_struct" href="structmz__zip__archive__file__stat.html">mz_zip_archive_file_stat</a> file_stat;</div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"> 1090</span>    <span class="keywordtype">void</span> *pRead_buf;</div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"> 1091</span>    <span class="keywordtype">void</span> *pWrite_buf;</div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"> 1092</span> </div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span>    <span class="keywordtype">size_t</span> out_blk_remain;</div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span> </div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span>    <a class="code hl_struct" href="structtinfl__decompressor__tag.html">tinfl_decompressor</a> inflator;</div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span> </div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"> 1097</span>} <a class="code hl_struct" href="structmz__zip__reader__extract__iter__state.html">mz_zip_reader_extract_iter_state</a>;</div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"> 1098</span> </div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span><span class="comment">/* -------- ZIP reading */</span></div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span> </div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span><span class="comment">/* Inits a ZIP archive reader. */</span></div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span><span class="comment">/* These functions read and validate the archive&#39;s central directory. */</span></div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span>mz_bool mz_zip_reader_init(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint64 size, mz_uint flags);</div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"> 1104</span> </div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"> 1105</span>mz_bool mz_zip_reader_init_mem(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">void</span> *pMem, <span class="keywordtype">size_t</span> size, mz_uint flags);</div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"> 1106</span> </div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"> 1107</span><span class="preprocessor">#ifndef MINIZ_NO_STDIO</span></div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span><span class="comment">/* Read a archive from a disk file. */</span></div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span><span class="comment">/* file_start_ofs is the file offset where the archive actually begins, or 0. */</span></div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span><span class="comment">/* actual_archive_size is the true total size of the archive, which may be smaller than the file&#39;s actual size on disk. If zero the entire file is treated as the archive. */</span></div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span>mz_bool mz_zip_reader_init_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint32 flags);</div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span>mz_bool mz_zip_reader_init_file_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);</div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"> 1113</span> </div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"> 1114</span><span class="comment">/* Read an archive from an already opened FILE, beginning at the current file position. */</span></div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span><span class="comment">/* The archive is assumed to be archive_size bytes long. If archive_size is &lt; 0, then the entire rest of the file is assumed to contain the archive. */</span></div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span><span class="comment">/* The FILE will NOT be closed when mz_zip_reader_end() is called. */</span></div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span>mz_bool mz_zip_reader_init_cfile(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);</div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"> 1118</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"> 1119</span> </div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"> 1120</span><span class="comment">/* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */</span></div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"> 1121</span>mz_bool mz_zip_reader_end(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span> </div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span><span class="comment">/* -------- ZIP reading or writing */</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span> </div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span><span class="comment">/* Clears a mz_zip_archive struct to all zeros. */</span></div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"> 1126</span><span class="comment">/* Important: This must be done before passing the struct to any mz_zip functions. */</span></div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span><span class="keywordtype">void</span> mz_zip_zero_struct(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span> </div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span>mz_zip_mode mz_zip_get_mode(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span>mz_zip_type mz_zip_get_type(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span> </div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"> 1132</span><span class="comment">/* Returns the total number of files in the archive. */</span></div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span>mz_uint mz_zip_reader_get_num_files(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"> 1134</span> </div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"> 1135</span>mz_uint64 mz_zip_get_archive_size(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"> 1136</span>mz_uint64 mz_zip_get_archive_file_start_offset(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"> 1137</span>MZ_FILE *mz_zip_get_cfile(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"> 1138</span> </div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span><span class="comment">/* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */</span></div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span><span class="keywordtype">size_t</span> mz_zip_read_archive_data(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint64 file_ofs, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> n);</div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"> 1141</span> </div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span><span class="comment">/* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */</span></div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span><span class="comment">/* Note that the m_last_error functionality is not thread safe. */</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"> 1144</span>mz_zip_error mz_zip_set_last_error(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_zip_error err_num);</div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span>mz_zip_error mz_zip_peek_last_error(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span>mz_zip_error mz_zip_clear_last_error(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span>mz_zip_error mz_zip_get_last_error(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01148" name="l01148"></a><span class="lineno"> 1148</span><span class="keyword">const</span> <span class="keywordtype">char</span> *mz_zip_get_error_string(mz_zip_error mz_err);</div>
<div class="line"><a id="l01149" name="l01149"></a><span class="lineno"> 1149</span> </div>
<div class="line"><a id="l01150" name="l01150"></a><span class="lineno"> 1150</span><span class="comment">/* MZ_TRUE if the archive file entry is a directory entry. */</span></div>
<div class="line"><a id="l01151" name="l01151"></a><span class="lineno"> 1151</span>mz_bool mz_zip_reader_is_file_a_directory(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index);</div>
<div class="line"><a id="l01152" name="l01152"></a><span class="lineno"> 1152</span> </div>
<div class="line"><a id="l01153" name="l01153"></a><span class="lineno"> 1153</span><span class="comment">/* MZ_TRUE if the file is encrypted/strong encrypted. */</span></div>
<div class="line"><a id="l01154" name="l01154"></a><span class="lineno"> 1154</span>mz_bool mz_zip_reader_is_file_encrypted(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index);</div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span> </div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span><span class="comment">/* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */</span></div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"> 1157</span>mz_bool mz_zip_reader_is_file_supported(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index);</div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span> </div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span><span class="comment">/* Retrieves the filename of an archive file entry. */</span></div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span><span class="comment">/* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */</span></div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span>mz_uint mz_zip_reader_get_filename(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, <span class="keywordtype">char</span> *pFilename, mz_uint filename_buf_size);</div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span> </div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span><span class="comment">/* Attempts to locates a file in the archive&#39;s central directory. */</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"> 1164</span><span class="comment">/* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */</span></div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"> 1165</span><span class="comment">/* Returns -1 if the file cannot be found. */</span></div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"> 1166</span><span class="keywordtype">int</span> mz_zip_reader_locate_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pName, <span class="keyword">const</span> <span class="keywordtype">char</span> *pComment, mz_uint flags);</div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span><span class="keywordtype">int</span> mz_zip_reader_locate_file_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pName, <span class="keyword">const</span> <span class="keywordtype">char</span> *pComment, mz_uint flags, mz_uint32 *file_index);</div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span> </div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span><span class="comment">/* Returns detailed information about an archive file entry. */</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span>mz_bool mz_zip_reader_file_stat(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, <a class="code hl_struct" href="structmz__zip__archive__file__stat.html">mz_zip_archive_file_stat</a> *pStat);</div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span> </div>
<div class="line"><a id="l01172" name="l01172"></a><span class="lineno"> 1172</span><span class="comment">/* MZ_TRUE if the file is in zip64 format. */</span></div>
<div class="line"><a id="l01173" name="l01173"></a><span class="lineno"> 1173</span><span class="comment">/* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */</span></div>
<div class="line"><a id="l01174" name="l01174"></a><span class="lineno"> 1174</span>mz_bool mz_zip_is_zip64(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01175" name="l01175"></a><span class="lineno"> 1175</span> </div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span><span class="comment">/* Returns the total central directory size in bytes. */</span></div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span><span class="comment">/* The current max supported size is &lt;= MZ_UINT32_MAX. */</span></div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"> 1178</span><span class="keywordtype">size_t</span> mz_zip_get_central_dir_size(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"> 1179</span> </div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"> 1180</span><span class="comment">/* Extracts a archive file to a memory buffer using no memory allocation. */</span></div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"> 1181</span><span class="comment">/* There must be at least enough room on the stack to store the inflator&#39;s state (~34KB or so). */</span></div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span>mz_bool mz_zip_reader_extract_to_mem_no_alloc(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, mz_uint flags, <span class="keywordtype">void</span> *pUser_read_buf, <span class="keywordtype">size_t</span> user_read_buf_size);</div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span>mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, mz_uint flags, <span class="keywordtype">void</span> *pUser_read_buf, <span class="keywordtype">size_t</span> user_read_buf_size);</div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span> </div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span><span class="comment">/* Extracts a archive file to a memory buffer. */</span></div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span>mz_bool mz_zip_reader_extract_to_mem(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, mz_uint flags);</div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span>mz_bool mz_zip_reader_extract_file_to_mem(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, mz_uint flags);</div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span> </div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span><span class="comment">/* Extracts a archive file to a dynamically allocated heap buffer. */</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span><span class="comment">/* The memory will be allocated via the mz_zip_archive&#39;s alloc/realloc functions. */</span></div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span><span class="comment">/* Returns NULL and sets the last error on failure. */</span></div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span><span class="keywordtype">void</span> *mz_zip_reader_extract_to_heap(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, <span class="keywordtype">size_t</span> *pSize, mz_uint flags);</div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span><span class="keywordtype">void</span> *mz_zip_reader_extract_file_to_heap(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, <span class="keywordtype">size_t</span> *pSize, mz_uint flags);</div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span> </div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span><span class="comment">/* Extracts a archive file using a callback function to output the file&#39;s data. */</span></div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span>mz_bool mz_zip_reader_extract_to_callback(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, mz_file_write_func pCallback, <span class="keywordtype">void</span> *pOpaque, mz_uint flags);</div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span>mz_bool mz_zip_reader_extract_file_to_callback(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_file_write_func pCallback, <span class="keywordtype">void</span> *pOpaque, mz_uint flags);</div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span> </div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span><span class="comment">/* Extract a file iteratively */</span></div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span><a class="code hl_struct" href="structmz__zip__reader__extract__iter__state.html">mz_zip_reader_extract_iter_state</a>* mz_zip_reader_extract_iter_new(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, mz_uint flags);</div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span><a class="code hl_struct" href="structmz__zip__reader__extract__iter__state.html">mz_zip_reader_extract_iter_state</a>* mz_zip_reader_extract_file_iter_new(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint flags);</div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span><span class="keywordtype">size_t</span> mz_zip_reader_extract_iter_read(<a class="code hl_struct" href="structmz__zip__reader__extract__iter__state.html">mz_zip_reader_extract_iter_state</a>* pState, <span class="keywordtype">void</span>* pvBuf, <span class="keywordtype">size_t</span> buf_size);</div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span>mz_bool mz_zip_reader_extract_iter_free(<a class="code hl_struct" href="structmz__zip__reader__extract__iter__state.html">mz_zip_reader_extract_iter_state</a>* pState);</div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span> </div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span><span class="preprocessor">#ifndef MINIZ_NO_STDIO</span></div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span><span class="comment">/* Extracts a archive file to a disk file and sets its last accessed and modified times. */</span></div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span><span class="comment">/* This function only extracts files, not archive directory records. */</span></div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span>mz_bool mz_zip_reader_extract_to_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, <span class="keyword">const</span> <span class="keywordtype">char</span> *pDst_filename, mz_uint flags);</div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span>mz_bool mz_zip_reader_extract_file_to_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *pDst_filename, mz_uint flags);</div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span> </div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span><span class="comment">/* Extracts a archive file starting at the current position in the destination FILE stream. */</span></div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span>mz_bool mz_zip_reader_extract_to_cfile(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);</div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span>mz_bool mz_zip_reader_extract_file_to_cfile(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_filename, MZ_FILE *pFile, mz_uint flags);</div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span> </div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"> 1216</span><span class="preprocessor">#if 0</span></div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"> 1217</span><span class="comment">/* TODO */</span></div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span>    <span class="keyword">typedef</span> <span class="keywordtype">void</span> *mz_zip_streaming_extract_state_ptr;</div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span>    mz_zip_streaming_extract_state_ptr mz_zip_streaming_extract_begin(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, mz_uint flags);</div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span>    uint64_t mz_zip_streaming_extract_get_size(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_zip_streaming_extract_state_ptr pState);</div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span>    uint64_t mz_zip_streaming_extract_get_cur_ofs(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_zip_streaming_extract_state_ptr pState);</div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span>    mz_bool mz_zip_streaming_extract_seek(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_zip_streaming_extract_state_ptr pState, uint64_t new_ofs);</div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span>    <span class="keywordtype">size_t</span> mz_zip_streaming_extract_read(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_zip_streaming_extract_state_ptr pState, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size);</div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span>    mz_bool mz_zip_streaming_extract_end(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_zip_streaming_extract_state_ptr pState);</div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span> </div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"> 1227</span><span class="comment">/* This function compares the archive&#39;s local headers, the optional local zip64 extended information block, and the optional descriptor following the compressed data vs. the data in the central directory. */</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"> 1228</span><span class="comment">/* It also validates that each file can be successfully uncompressed unless the MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY is specified. */</span></div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"> 1229</span>mz_bool mz_zip_validate_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint file_index, mz_uint flags);</div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"> 1230</span> </div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span><span class="comment">/* Validates an entire archive by calling mz_zip_validate_file() on each file. */</span></div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span>mz_bool mz_zip_validate_archive(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint flags);</div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span> </div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span><span class="comment">/* Misc utils/helpers, valid for ZIP reading or writing */</span></div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span>mz_bool mz_zip_validate_mem_archive(<span class="keyword">const</span> <span class="keywordtype">void</span> *pMem, <span class="keywordtype">size_t</span> size, mz_uint flags, mz_zip_error *pErr);</div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span>mz_bool mz_zip_validate_file_archive(<span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint flags, mz_zip_error *pErr);</div>
<div class="line"><a id="l01237" name="l01237"></a><span class="lineno"> 1237</span> </div>
<div class="line"><a id="l01238" name="l01238"></a><span class="lineno"> 1238</span><span class="comment">/* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */</span></div>
<div class="line"><a id="l01239" name="l01239"></a><span class="lineno"> 1239</span>mz_bool mz_zip_end(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"> 1240</span> </div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"> 1241</span><span class="comment">/* -------- ZIP writing */</span></div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"> 1242</span> </div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"> 1243</span><span class="preprocessor">#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS</span></div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span> </div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span><span class="comment">/* Inits a ZIP archive writer. */</span></div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span><span class="comment">/*Set pZip-&gt;m_pWrite (and pZip-&gt;m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/</span></div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span><span class="comment">/*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/</span></div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span>mz_bool mz_zip_writer_init(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint64 existing_size);</div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span>mz_bool mz_zip_writer_init_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, mz_uint64 existing_size, mz_uint flags);</div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span> </div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span>mz_bool mz_zip_writer_init_heap(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keywordtype">size_t</span> size_to_reserve_at_beginning, <span class="keywordtype">size_t</span> initial_allocation_size);</div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span>mz_bool mz_zip_writer_init_heap_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keywordtype">size_t</span> size_to_reserve_at_beginning, <span class="keywordtype">size_t</span> initial_allocation_size, mz_uint flags);</div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span> </div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span><span class="preprocessor">#ifndef MINIZ_NO_STDIO</span></div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span>mz_bool mz_zip_writer_init_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint64 size_to_reserve_at_beginning);</div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span>mz_bool mz_zip_writer_init_file_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);</div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span>mz_bool mz_zip_writer_init_cfile(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, MZ_FILE *pFile, mz_uint flags);</div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span> </div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span><span class="comment">/* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */</span></div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span><span class="comment">/* For archives opened using mz_zip_reader_init_file, pFilename must be the archive&#39;s filename so it can be reopened for writing. If the file can&#39;t be reopened, mz_zip_reader_end() will be called. */</span></div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span><span class="comment">/* For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you&#39;ve overridden it). */</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span><span class="comment">/* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive&#39;s user provided m_pWrite function cannot be NULL. */</span></div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span><span class="comment">/* Note: In-place archive modification is not recommended unless you know what you&#39;re doing, because if execution stops or something goes wrong before */</span></div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span><span class="comment">/* the archive is finalized the file&#39;s central directory will be hosed. */</span></div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span>mz_bool mz_zip_writer_init_from_reader(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename);</div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"> 1267</span>mz_bool mz_zip_writer_init_from_reader_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFilename, mz_uint flags);</div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"> 1268</span> </div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"> 1269</span><span class="comment">/* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */</span></div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"> 1270</span><span class="comment">/* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */</span></div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span><span class="comment">/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR&#39;d with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */</span></div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span>mz_bool mz_zip_writer_add_mem(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, mz_uint level_and_flags);</div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span> </div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span><span class="comment">/* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */</span></div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"> 1275</span><span class="comment">/* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */</span></div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span>mz_bool mz_zip_writer_add_mem_ex(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags,</div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"> 1277</span>                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);</div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span> </div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span>mz_bool mz_zip_writer_add_mem_ex_v2(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags,</div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span>                                    mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, <span class="keyword">const</span> <span class="keywordtype">char</span> *user_extra_data_local, mz_uint user_extra_data_local_len,</div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span>                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *user_extra_data_central, mz_uint user_extra_data_central_len);</div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span> </div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span><span class="comment">/* Adds the contents of a file to an archive. This function also records the disk file&#39;s modified time into the archive. */</span></div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span><span class="comment">/* File data is supplied via a read callback function. User mz_zip_writer_add_(c)file to add a file directly.*/</span></div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span>mz_bool mz_zip_writer_add_read_buf_callback(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, mz_file_read_func read_callback, <span class="keywordtype">void</span>* callback_opaque, mz_uint64 size_to_add,</div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span>    <span class="keyword">const</span> MZ_TIME_T *pFile_time, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags, <span class="keyword">const</span> <span class="keywordtype">char</span> *user_extra_data_local, mz_uint user_extra_data_local_len,</div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span>    <span class="keyword">const</span> <span class="keywordtype">char</span> *user_extra_data_central, mz_uint user_extra_data_central_len);</div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span> </div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"> 1289</span><span class="preprocessor">#ifndef MINIZ_NO_STDIO</span></div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"> 1290</span><span class="comment">/* Adds the contents of a disk file to an archive. This function also records the disk file&#39;s modified time into the archive. */</span></div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"> 1291</span><span class="comment">/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR&#39;d with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */</span></div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"> 1292</span>mz_bool mz_zip_writer_add_file(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *pSrc_filename, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags);</div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"> 1293</span> </div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span><span class="comment">/* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */</span></div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span>mz_bool mz_zip_writer_add_cfile(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 size_to_add,</div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span>                                <span class="keyword">const</span> MZ_TIME_T *pFile_time, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags, <span class="keyword">const</span> <span class="keywordtype">char</span> *user_extra_data_local, mz_uint user_extra_data_local_len,</div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span>                                <span class="keyword">const</span> <span class="keywordtype">char</span> *user_extra_data_central, mz_uint user_extra_data_central_len);</div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span> </div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span><span class="comment">/* Adds a file to an archive by fully cloning the data from another archive. */</span></div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"> 1301</span><span class="comment">/* This function fully clones the source file&#39;s compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */</span></div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span>mz_bool mz_zip_writer_add_from_zip_reader(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pSource_zip, mz_uint src_file_index);</div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"> 1303</span> </div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span><span class="comment">/* Finalizes the archive by writing the central directory records followed by the end of central directory record. */</span></div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"> 1305</span><span class="comment">/* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */</span></div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span><span class="comment">/* An archive must be manually finalized by calling this function for it to be valid. */</span></div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span>mz_bool mz_zip_writer_finalize_archive(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span> </div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span><span class="comment">/* Finalizes a heap archive, returning a poiner to the heap block and its size. */</span></div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"> 1310</span><span class="comment">/* The heap block will be allocated using the mz_zip_archive&#39;s alloc/realloc callbacks. */</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"> 1311</span>mz_bool mz_zip_writer_finalize_heap_archive(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip, <span class="keywordtype">void</span> **ppBuf, <span class="keywordtype">size_t</span> *pSize);</div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"> 1312</span> </div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span><span class="comment">/* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */</span></div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span><span class="comment">/* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */</span></div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"> 1315</span>mz_bool mz_zip_writer_end(<a class="code hl_struct" href="structmz__zip__archive.html">mz_zip_archive</a> *pZip);</div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span> </div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span><span class="comment">/* -------- Misc. high-level helper functions: */</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span> </div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span><span class="comment">/* mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive. */</span></div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span><span class="comment">/* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */</span></div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span><span class="comment">/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR&#39;d with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */</span></div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span><span class="comment">/* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */</span></div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"> 1323</span>mz_bool mz_zip_add_mem_to_archive_file_in_place(<span class="keyword">const</span> <span class="keywordtype">char</span> *pZip_filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags);</div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"> 1324</span>mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(<span class="keyword">const</span> <span class="keywordtype">char</span> *pZip_filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_size, <span class="keyword">const</span> <span class="keywordtype">void</span> *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);</div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"> 1325</span> </div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span><span class="comment">/* Reads a single file from an archive into a heap block. */</span></div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"> 1327</span><span class="comment">/* If pComment is not NULL, only the file with the specified comment will be extracted. */</span></div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span><span class="comment">/* Returns NULL on failure. */</span></div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span><span class="keywordtype">void</span> *mz_zip_extract_archive_file_to_heap(<span class="keyword">const</span> <span class="keywordtype">char</span> *pZip_filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keywordtype">size_t</span> *pSize, mz_uint flags);</div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"> 1330</span><span class="keywordtype">void</span> *mz_zip_extract_archive_file_to_heap_v2(<span class="keyword">const</span> <span class="keywordtype">char</span> *pZip_filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *pArchive_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *pComment, <span class="keywordtype">size_t</span> *pSize, mz_uint flags, mz_zip_error *pErr);</div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span> </div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span><span class="preprocessor">#endif </span><span class="comment">/* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */</span><span class="preprocessor"></span></div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span> </div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span>}</div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span> </div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span><span class="preprocessor">#endif </span><span class="comment">/* MINIZ_NO_ARCHIVE_APIS */</span><span class="preprocessor"></span></div>
<div class="ttc" id="astructmz__dummy__time__t__tag_html"><div class="ttname"><a href="structmz__dummy__time__t__tag.html">mz_dummy_time_t_tag</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l00512">miniz.h:513</a></div></div>
<div class="ttc" id="astructmz__stream__s_html"><div class="ttname"><a href="structmz__stream__s.html">mz_stream_s</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l00282">miniz.h:283</a></div></div>
<div class="ttc" id="astructmz__zip__archive__file__stat_html"><div class="ttname"><a href="structmz__zip__archive__file__stat.html">mz_zip_archive_file_stat</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l00923">miniz.h:924</a></div></div>
<div class="ttc" id="astructmz__zip__archive_html"><div class="ttname"><a href="structmz__zip__archive.html">mz_zip_archive</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l01052">miniz.h:1053</a></div></div>
<div class="ttc" id="astructmz__zip__internal__state__tag_html"><div class="ttname"><a href="structmz__zip__internal__state__tag.html">mz_zip_internal_state_tag</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8cpp_source.html#l03224">miniz.cpp:3225</a></div></div>
<div class="ttc" id="astructmz__zip__reader__extract__iter__state_html"><div class="ttname"><a href="structmz__zip__reader__extract__iter__state.html">mz_zip_reader_extract_iter_state</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l01079">miniz.h:1080</a></div></div>
<div class="ttc" id="astructtdefl__compressor_html"><div class="ttname"><a href="structtdefl__compressor.html">tdefl_compressor</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l00698">miniz.h:699</a></div></div>
<div class="ttc" id="astructtinfl__decompressor__tag_html"><div class="ttname"><a href="structtinfl__decompressor__tag.html">tinfl_decompressor_tag</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l00891">miniz.h:892</a></div></div>
<div class="ttc" id="astructtinfl__huff__table_html"><div class="ttname"><a href="structtinfl__huff__table.html">tinfl_huff_table</a></div><div class="ttdef"><b>Definition:</b> <a href="miniz_8h_source.html#l00871">miniz.h:872</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<section class="main-content">
 <footer class="site-footer">
  <span class="site-footer-owner">
   Generated on Thu Jun 5 2025 10:29:22 for Pencil2D by&#160;<a href="https://www.doxygen.org/index.html">doxygen</a> 1.9.6
  </span>
  <span class="site-footer-credits">
   based on revision 44536aad40f3b5ffbb25cd8e9cab5cbd12c5cfbe
  </span>
  <!-- SVG icons from https://iconmonstr.com -->
  <!-- Github icon -->
  <span class="my-span-icon">
   <a href="https://github.com/pencil2d/pencil" aria-label="pencil2d's GitHub" title="pencil2d's GitHub">
    <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
   </a>
  </span>
  <!-- Bitbucket icon -->
  <span class="my-span-icon">
   <a href="https://bitbucket.org/chchwy/pencil2d" aria-label="pencil2d's Bitbucket" title="pencil2d's Bitbucket">
    <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-6.551 6.411l13.101.023c.28 0 0.49.233.443.513l-1.912 11.679c-.047.21-.233.373-.443.373h-9.138c-.303 0-.559-.21-.606-.513l-1.888-11.563c-.047-.256.163-.513.443-.513zm8.019 8.346h-2.914l-.769-4.126h4.406l-.723 4.126z"/></svg>
   </a>
  </span>
  <!-- Twitter icon -->
  <span class="my-span-icon">
   <a href="https://twitter.com/pencil2d" aria-label="pencil2d's Twitter" title="pencil2d's Twitter">
    <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
   </a>
  </span>
  <!-- Contact icon -->
  <span class="my-span-icon">
   <a href="mailto:pencil2danimation@gmail.com" aria-label="Contact" title="Contact pencil2d">
    <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
   </a>
  </span>
 </footer>
</section>
</body>
</html>
